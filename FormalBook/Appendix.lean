import Mathlib.Tactic

noncomputable section

open ValuationSubring
open Algebra

-- Any maximal subring of ℝ not containing 1/2 is a valuation ring.
lemma inclusion_maximal_valuation (B : Subring ℝ) (h1 : (1/2) ∉ B)
(h2 : ∀(C : Subring ℝ), (B ≤ C) ∧ (1/2) ∉ C → B = C) : ∃(D : ValuationSubring ℝ), D.toSubring = B := by
  -- We assume that B is not a valuationring
  by_contra no_vr
  have alpha_existence : ∃(α : ℝ), (α ∉ B ∧ α⁻¹ ∉ B) := by
  -- This is true, because B is not a valuationring
    by_contra H
    rw[← not_forall_not, not_not] at H
    simp_rw[← or_iff_not_and_not] at H
    let D : ValuationSubring ℝ :=
      { B with
        mem_or_inv_mem' := H}
    have for_contra : ∃ (D : ValuationSubring ℝ), D.toSubring = B := by
      use D
    tauto
  cases' alpha_existence with α H
  -- We consider B[α], B[α⁻¹] (as algebras over B)
  let Balpha := adjoin B {α}
  let Balpha' := adjoin B {α⁻¹}
  -- We consider {2} as a subset of Balpha and {2} as a subset of Balpha'
  let (two : Set Balpha.toSubring) := {2}
  let (two' : Set Balpha'.toSubring) := {2}
  -- We view 2B[α], 2B[α⁻¹] as principle ideals,
  -- i.e. submodules generated by 1 element
  let twoBalpha := Submodule.span Balpha.toSubring two
  let twoBalpha' := Submodule.span Balpha'.toSubring two'


  have Balpha_contains_half : 1/2 ∈ Balpha := by
  -- otherwise there is a contradiction with maximality
    by_contra h
    have B_leq_Balpha : B ≤ Balpha.toSubring := by
      -- B is a subring of B[α]
      intro x h'
      have x_is_y : ∃ y : B, y = x := CanLift.prf x h'
      cases' x_is_y with y x_is_y'
      have H : (algebraMap B ℝ) y = x := x_is_y'
      rw[← H]
      apply Subalgebra.algebraMap_mem'
    have B_is_Balpha : B = Balpha.toSubring := by
      -- Here we use the maximality of B
      exact h2 Balpha.toSubring ⟨B_leq_Balpha, h⟩
    have alpha_in_Balpha : α ∈ Balpha.toSubring := subset_adjoin rfl
    have Balpha_leq_B : Balpha.toSubring ≤ B := by
      exact le_of_eq_of_le (_root_.id (Eq.symm B_is_Balpha)) fun ⦃x⦄ a ↦ a
    have alpha_in_B : α ∈ B := Balpha_leq_B alpha_in_Balpha
    -- We have now shown that α ∈ B, but we also know that α ∉ B by assumption
    -- therefore we obtain a contradiction
    rw[← false_iff] at H
    rwa[H.1]


  have Balpha'_contains_half : 1/2 ∈ Balpha' := by
    -- This is essentially the same proof as above, only with primes
    by_contra h
    have B_leq_Balpha' : B ≤ Balpha'.toSubring := by
      -- B is a subring of B[α⁻¹]
      intro x h'
      have x_is_y : ∃ y : B, y = x := CanLift.prf x h'
      cases' x_is_y with y x_is_y'
      have H : (algebraMap B ℝ) y = x := x_is_y'
      rw[← H]
      apply Subalgebra.algebraMap_mem'
    have B_is_Balpha' : B = Balpha'.toSubring := by
      -- Here we use the maximality of B
      exact h2 Balpha'.toSubring ⟨B_leq_Balpha', h⟩
    have alpha_in_Balpha' : α⁻¹ ∈ Balpha'.toSubring := subset_adjoin rfl
    have Balpha'_leq_B : Balpha'.toSubring ≤ B := by
      exact le_of_eq_of_le (_root_.id (Eq.symm B_is_Balpha')) fun ⦃x⦄ a ↦ a
    have alpha_in_B : α⁻¹ ∈ B := Balpha'_leq_B alpha_in_Balpha'
    -- We have now shown that α⁻¹ ∈ B, but we also know that α⁻¹ ∉ B by assumption
    -- therefore we obtain a contradiction
    have one_last : α⁻¹ ∉ B := H.2
    rw[← false_iff] at one_last
    rwa[one_last]


  -- We now want to say something like:
  -- have rings_equal : twoBalpha = Balpha ∧ twoBalpha' = Balpha'
  -- This does not work yet, because the types are different.
  sorry


-- There exists a valuation subring of ℝ not containing 1/2.
lemma valuation_ring_no_half : ∃(B : ValuationSubring ℝ), (1/2) ∉ B := by
  let S := {A : Subring ℝ | (1/2) ∉ A}
  have h1 : ∀ c ⊆ S, IsChain (· ≤ ·) c → ∃ ub ∈ S, ∀ z ∈ c, z ≤ ub := by
    -- Idea: The upper bound is the union of the subrings.

    sorry
  have h2 := zorn_le₀ S h1
  rcases h2 with ⟨B, hl, hr⟩
  have h3 : ∀(C : Subring ℝ), (B ≤ C) ∧ (1/2) ∉ C → B = C := by
    -- Idea: This is exactly hr, so maybe change statement of
    -- inclusion_maximal_valuation to have hr as hypothesis.
    rintro y ⟨h6, h7⟩
    have h8 : y ∈ S := by
      exact h7
    have h5 : y ≤ B := hr h8 h6
    exact LE.le.antisymm h6 h5
  have h4 := inclusion_maximal_valuation B hl h3
  cases' h4 with D hd
  use D
  -- Idea: B ∈ S so (1/2) ∉ B. D=B implies (1/2) ∉ D.
  -- Maybe again try to change statement of inclusion_maximal_valuation to:
  -- B is a valuation ring.
  -- have B_no_half : 1/2 ∉ B := hl
  have D_no_half : 1/2 ∉ D.toSubring := by
    rwa[hd]
  exact D_no_half


lemma non_archimedean (Γ₀ : Type) [LinearOrderedCommGroupWithZero Γ₀] (K : Type) [Field K] (v : Valuation K Γ₀) :
  (∀(x y : K), v x ≠ v y → v (x + y) = max (v x) (v y)) := by
  exact fun x y a ↦ Valuation.map_add_of_distinct_val v a


-- There is a valuation v on ℝ such that v(1/2) > 1.
theorem valuation_on_reals : ∃(Γ₀ : Type) (_ : LinearOrderedCommGroupWithZero Γ₀)
  (v : Valuation ℝ Γ₀), (v (1/2)) > 1 := by
    have h := valuation_ring_no_half
    cases' h with B h
    use B.ValueGroup, inferInstance, B.valuation
    have g := valuation_le_one_iff B (1/2)
    rw[← not_iff_not] at g
    rwa[gt_iff_lt, ← not_le, g]
