import Mathlib.Tactic

noncomputable section

open ValuationSubring
open Algebra
open Polynomial

-- Any maximal subring of ℝ not containing 1/2 is a valuation ring.
lemma inclusion_maximal_valuation (B : Subring ℝ) (h1 : (1/2) ∉ B)
(h2 : ∀(C : Subring ℝ), (B ≤ C) ∧ (1/2) ∉ C → B = C) : ∃(D : ValuationSubring ℝ), D.toSubring = B := by
  -- We assume that B is not a valuationring
  by_contra no_vr
  have alpha_existence : ∃(α : ℝ), (α ∉ B ∧ α⁻¹ ∉ B) := by
  -- This is true, because B is not a valuationring
    by_contra H
    rw[← not_forall_not, not_not] at H
    simp_rw[← or_iff_not_and_not] at H
    let D : ValuationSubring ℝ :=
      { B with
        mem_or_inv_mem' := H}
    have for_contra : ∃ (D : ValuationSubring ℝ), D.toSubring = B := by
      use D
    tauto
  cases' alpha_existence with α H
  -- We consider B[α], B[α⁻¹] (as algebras over B)
  let Balpha := adjoin B {α}
  let Balpha' := adjoin B {α⁻¹}

  have alpha_in_Balpha : α ∈ Balpha := subset_adjoin rfl
  have alpha_in_Balpha' : α⁻¹ ∈ Balpha' := subset_adjoin rfl

  have algebramap : ∀x : B, (algebraMap ↥B ℝ) x = x := by
    intro x
    rfl
  -- -- We consider {2} as a subset of Balpha and {2} as a subset of Balpha'
  -- let (two : Set Balpha.toSubring) := {2}
  -- let (two' : Set Balpha'.toSubring) := {2}
  -- -- We view 2B[α], 2B[α⁻¹] as principle ideals,
  -- -- i.e. submodules generated by 1 element
  -- let twoBalpha := Submodule.span Balpha.toSubring two
  -- let twoBalpha' := Submodule.span Balpha'.toSubring two'


  have Balpha_contains_half : 1/2 ∈ Balpha := by
  -- otherwise there is a contradiction with maximality
    by_contra h
    have B_leq_Balpha : B ≤ Balpha.toSubring := by
      -- B is a subring of B[α]
      intro x h'
      lift x to B using h'
      apply Subalgebra.algebraMap_mem'
    have B_is_Balpha : B = Balpha.toSubring := by
      -- Here we use the maximality of B
      exact h2 Balpha.toSubring ⟨B_leq_Balpha, h⟩
    have Balpha_leq_B : Balpha.toSubring ≤ B := by
      exact le_of_eq_of_le (_root_.id (Eq.symm B_is_Balpha)) fun ⦃x⦄ a ↦ a
    have alpha_in_B : α ∈ B := Balpha_leq_B alpha_in_Balpha
    -- We have now shown that α ∈ B, but we also know that α ∉ B by assumption
    -- therefore we obtain a contradiction
    rw[← false_iff] at H
    rwa[H.1]


  have Balpha'_contains_half : 1/2 ∈ Balpha' := by
    -- This is essentially the same proof as above, only with primes
    by_contra h
    have B_leq_Balpha' : B ≤ Balpha'.toSubring := by
      -- B is a subring of B[α⁻¹]
      intro x h'
      lift x to B using h'
      apply Subalgebra.algebraMap_mem'
    have B_is_Balpha' : B = Balpha'.toSubring := by
      -- Here we use the maximality of B
      exact h2 Balpha'.toSubring ⟨B_leq_Balpha', h⟩
    have Balpha'_leq_B : Balpha'.toSubring ≤ B := by
      exact le_of_eq_of_le (_root_.id (Eq.symm B_is_Balpha')) fun ⦃x⦄ a ↦ a
    have alpha_in_B : α⁻¹ ∈ B := Balpha'_leq_B alpha_in_Balpha'
    -- We have now shown that α⁻¹ ∈ B, but we also know that α⁻¹ ∉ B by assumption
    -- therefore we obtain a contradiction
    have one_last : α⁻¹ ∉ B := H.2
    rw[← false_iff] at one_last
    rwa[one_last]

  let degree : Set ℕ := {n : ℕ | ∃(p : Polynomial B), p.natDegree = n ∧ (Polynomial.aeval α) p = 1/2}
  let degree' : Set ℕ := {n : ℕ | ∃(p : Polynomial B), p.natDegree = n ∧ (Polynomial.aeval α⁻¹) p = 1/2}

  -- any element of B[α] can be written as a polynomial in α with variables in B
  have contains_half : 1/2 ∈ ((Polynomial.aeval α).range : Subalgebra ↥B ℝ) := by
    rw[← adjoin_singleton_eq_range_aeval B α]
    exact Balpha_contains_half

  have is_nonempty : degree ≠ ∅ := by
    intro is_empty
    rcases contains_half with ⟨p, eval⟩
    have deg : p.natDegree ∈ degree := by
      exact ⟨p, by rfl, eval⟩
    rw[is_empty] at deg
    tauto

  have nonempty : degree.Nonempty := by
    exact Set.nonempty_iff_ne_empty.mpr is_nonempty

  -- any element of B[α⁻¹] can be written as a polynomial in α⁻¹ with variables in B
  have contains_half' : 1/2 ∈ ((Polynomial.aeval α⁻¹).range : Subalgebra ↥B ℝ) := by
    rw[← adjoin_singleton_eq_range_aeval B α⁻¹]
    exact Balpha'_contains_half

  have is_nonempty' : degree' ≠ ∅ := by
    intro is_empty
    rcases contains_half' with ⟨p, eval⟩
    have deg : p.natDegree ∈ degree' := by
      exact ⟨p, by rfl, eval⟩
    rw[is_empty] at deg
    tauto

  have nonempty' : degree'.Nonempty := by
    exact Set.nonempty_iff_ne_empty.mpr is_nonempty'

  -- Since the natural numbers are well-founded and degree and degree' are
  -- non-empty, we may conclude that degree and degree' have a minimal element
  let m := WellFounded.min wellFounded_lt degree nonempty
  let n := WellFounded.min wellFounded_lt degree' nonempty'

  have m_mem : m ∈ degree := WellFounded.min_mem wellFounded_lt degree nonempty
  have n_mem : n ∈ degree' := WellFounded.min_mem wellFounded_lt degree' nonempty'
  rcases m_mem with ⟨p, m_eq_degree_p, p_eval⟩
  rcases n_mem with ⟨q, n_eq_degree_q, q_eval⟩

  -- m and n are not equal to zero, because otherwise 1/2 would be in B
  -- We use that a polynomial of degree zero is constant and  that the
  -- evalauation of a contant polynomial lands in B (Polynomial.aeval_C)
  have zero_lt_m : m ≠ 0 := by
    intro m_eq_zero
    rw[← m_eq_degree_p, Polynomial.natDegree_eq_zero] at m_eq_zero
    rcases m_eq_zero with ⟨x, eq⟩
    rw[← eq, Polynomial.aeval_C, algebramap x] at p_eval
    rw[← p_eval] at h1
    apply h1
    exact SetLike.coe_mem x

  have zero_lt_n : n ≠ 0 := by
    intro n_eq_zero
    rw[← n_eq_degree_q, natDegree_eq_zero] at n_eq_zero
    rcases n_eq_zero with ⟨x, eq⟩
    rw[← eq, aeval_C, algebramap x] at q_eval
    rw[← q_eval] at h1
    apply h1
    exact SetLike.coe_mem x

  let v₀ := coeff q 0
  let two_v₀ := 2*v₀
  let one_minus_two_v₀ := 1-two_v₀

  by_cases leq : n ≤ m

  have lower_degree : (n-1) ∈ degree := by
    have two_eq_constant : C (2:B) = (2 : Polynomial ↥B) := by rfl
    have two_p_eval : (aeval α) (2 * p) = 1 := by
      rw[← two_eq_constant, map_mul, aeval_C, algebramap 2, p_eval]
      simp
      exact CommGroupWithZero.mul_inv_cancel 2 (Ne.symm (NeZero.ne' 2))
    have constant_in_poly :
      ∀(b : B), ∀(p : Polynomial B), (aeval α) ((C b) * p) = b * (aeval α) p := by
        intro b p
        rw[map_mul, aeval_C, algebramap b]
    have one_minus_two_v₀_eq : (aeval α) ((C one_minus_two_v₀) * (2*p)) = one_minus_two_v₀ := by
      rw[constant_in_poly one_minus_two_v₀ (2*p), two_p_eval]
      simp
    have one_eq : 1 = (aeval α) ((C one_minus_two_v₀) * (2*p) + (C two_v₀)) := by
      rw[← Eq.symm (aeval_add α), aeval_C, algebramap (two_v₀), one_minus_two_v₀_eq]
      exact sub_eq_iff_eq_add.mp rfl
    sorry
  sorry
  sorry

def S := {A : Subring ℝ | (1/2) ∉ A}
def Z := (Int.castRingHom ℝ).range

lemma Z_in_S : Z ∈ S := by
  have two_eq_two : (Int.castRingHom ℝ) 2 = 2 := by rfl
  intro half_in_Z
  simp at half_in_Z
  rcases half_in_Z with ⟨n, h⟩
  rw[← two_eq_two] at h
  have inj : (Int.castRingHom ℝ).toFun.Injective := by
    exact Isometry.injective fun x1 ↦ congrFun rfl
  have two_n : (Int.castRingHom ℝ) (2*n) = 1 := by
    rw[map_mul, h]
    simp
  rw[← (Int.castRingHom ℝ).map_one] at two_n
  have two_n_eq_one : 2*n = 1 := by
    exact (inj two_n)
  have n_two_eq_one : n*2 = 1 := by
    rw[← two_n_eq_one]
    exact Int.mul_comm n 2
  have two_unit : ∃two : ℤˣ, two = (2:ℤ) := by
    refine CanLift.prf 2 ?_
    rw[isUnit_iff_exists]
    use n
  rcases two_unit with ⟨two, H⟩
  cases' (Int.units_eq_one_or two) with l l <;> (rw[l] at H; tauto)

lemma sUnion_is_ub : ∀ c ⊆ S, IsChain (· ≤ ·) c → ∃ ub ∈ S, ∀ z ∈ c, z ≤ ub := by
-- Idea: The upper bound is the union of the subrings.
  intro c subset chain
  by_cases emp_or_not : c ≠ ∅
  let subring_to_set_of_sets : Set (Set ℝ) :=
    {Rset : Set ℝ | ∃R : Subring ℝ, R ∈ c ∧ Rset = R.carrier}
  let union_of_sets : Set ℝ := ⋃₀ subring_to_set_of_sets
  let ub : Subring ℝ :=
    { carrier := union_of_sets,
      zero_mem' := by
        have in_c : ∃(t : Subring ℝ), t ∈ c := by exact Set.nonempty_iff_ne_empty.mpr emp_or_not
        cases' in_c with t in_c
        exact Set.mem_sUnion.mpr ⟨t.carrier, ⟨t, in_c, by rfl⟩, t.zero_mem'⟩
      one_mem' := by
        have in_c : ∃(t : Subring ℝ), t ∈ c := by exact Set.nonempty_iff_ne_empty.mpr emp_or_not
        cases' in_c with t in_c
        exact Set.mem_sUnion.mpr ⟨t.carrier, ⟨t, in_c, by rfl⟩, t.one_mem'⟩
      add_mem' := by
        intro a b a_in_carrier b_in_carrier
        refine Set.mem_sUnion.mpr ?_
        rcases a_in_carrier with ⟨cara, hypa, a_in_cara⟩
        rcases b_in_carrier with ⟨carb, hypb, b_in_carb⟩
        have hypa' := hypa
        have hypb' := hypb
        rcases hypa with ⟨ringa, H1a, H2a⟩
        rcases hypb with ⟨ringb, H1b, H2b⟩
        have antisymm : ringa ≤ ringb ∨ ringb ≤ ringa := by
          exact IsChain.total chain H1a H1b
        cases' antisymm with l r
        . use carb
          have cara_subset_carb : cara ≤ carb := by
            rwa[H2a, H2b]
          have a_and_b_in_carb : a ∈ ringb ∧ b ∈ ringb := by
            repeat rw[← Subring.mem_carrier]
            rw[← H2b]
            exact ⟨cara_subset_carb a_in_cara, b_in_carb⟩
          have a_plus_b_in_ringb : a+b ∈ ringb := by
            exact (ringb.add_mem' a_and_b_in_carb.1 a_and_b_in_carb.2)
          exact ⟨hypb', by rwa[H2b]⟩
        . use cara
          have carb_subset_cara : carb ≤ cara := by
            rwa[H2b, H2a]
          have a_and_b_in_cara : a ∈ ringa ∧ b ∈ ringa := by
            repeat rw[← Subring.mem_carrier]
            rw[← H2a]
            exact ⟨a_in_cara, carb_subset_cara b_in_carb⟩
          have a_plus_b_in_ringa : a+b ∈ ringa := by
            exact (ringa.add_mem' a_and_b_in_cara.1 a_and_b_in_cara.2)
          exact ⟨hypa', by rwa[H2a]⟩,
      mul_mem' := by
        intro a b a_in_carrier b_in_carrier
        refine Set.mem_sUnion.mpr ?_
        rcases a_in_carrier with ⟨cara, hypa, a_in_cara⟩
        rcases b_in_carrier with ⟨carb, hypb, b_in_carb⟩
        have hypa' := hypa
        have hypb' := hypb
        rcases hypa with ⟨ringa, H1a, H2a⟩
        rcases hypb with ⟨ringb, H1b, H2b⟩
        have antisymm : ringa ≤ ringb ∨ ringb ≤ ringa := by
          exact IsChain.total chain H1a H1b
        cases' antisymm with l r
        . use carb
          have cara_subset_carb : cara ≤ carb := by
            rwa[H2a, H2b]
          have a_and_b_in_carb : a ∈ ringb ∧ b ∈ ringb := by
            repeat rw[← Subring.mem_carrier]
            rw[← H2b]
            exact ⟨cara_subset_carb a_in_cara, b_in_carb⟩
          have a_plus_b_in_ringb : a*b ∈ ringb := by
            exact (ringb.mul_mem' a_and_b_in_carb.1 a_and_b_in_carb.2)
          exact ⟨hypb', by rwa[H2b]⟩
        . use cara
          have carb_subset_cara : carb ≤ cara := by
            rwa[H2b, H2a]
          have a_and_b_in_cara : a ∈ ringa ∧ b ∈ ringa := by
            repeat rw[← Subring.mem_carrier]
            rw[← H2a]
            exact ⟨a_in_cara, carb_subset_cara b_in_carb⟩
          have a_plus_b_in_ringa : a*b ∈ ringa := by
            exact (ringa.mul_mem' a_and_b_in_cara.1 a_and_b_in_cara.2)
          exact ⟨hypa', by rwa[H2a]⟩,
      neg_mem' := by
        intro a a_in_carrier
        rcases a_in_carrier with ⟨cara, hypa, a_in_cara⟩
        have hypa' := hypa
        rcases hypa with ⟨ringa, H1a, H2a⟩
        refine Set.mem_sUnion.mpr ?intro.intro.intro.intro.a
        use cara
        constructor
        . exact hypa'
        . rw[H2a, Subring.mem_carrier]
          rw[H2a, Subring.mem_carrier] at a_in_cara
          exact Subring.neg_mem ringa a_in_cara}

  have ub_carrier_non_half : 1/2 ∉ ub.carrier := by
    intro half_in
    rw[Set.mem_sUnion] at half_in
    rcases half_in with ⟨t, h, g⟩
    rcases h with ⟨ringt, H2, H3⟩
    have half_not_in_t : 1/2 ∉ t := by exact Eq.mpr_not (congrFun H3 (1 / 2)) (subset H2)
    tauto
  have ub_mem_S : ub ∈ S := by
    exact ub_carrier_non_half
  use ub
  constructor
  · exact ub_mem_S
  · intro z hz x hx
    exact Subring.mem_carrier.mp (Set.mem_sUnion.mpr ⟨z, ⟨z, hz, by rfl⟩, hx⟩)
  simp at emp_or_not
  use Z
  constructor
  . exact Z_in_S
  . rw[emp_or_not, Set.forall_mem_empty]
    trivial

lemma valuation_ring_no_half : ∃(B : ValuationSubring ℝ), (1/2) ∉ B := by
  have h2 := zorn_le₀ S sUnion_is_ub
  rcases h2 with ⟨B, hl, hr⟩
  have h3 : ∀(C : Subring ℝ), (B ≤ C) ∧ (1/2) ∉ C → B = C := by
    rintro y ⟨h6, h7⟩
    have h8 : y ∈ S := by
      exact h7
    have h5 : y ≤ B := hr h8 h6
    exact LE.le.antisymm h6 h5
  have h4 := inclusion_maximal_valuation B hl h3
  cases' h4 with D hd
  use D
  have D_no_half : 1/2 ∉ D.toSubring := by
    rwa[hd]
  exact D_no_half


lemma non_archimedean (Γ₀ : Type) [LinearOrderedCommGroupWithZero Γ₀] (K : Type) [Field K] (v : Valuation K Γ₀) :
  (∀(x y : K), v x ≠ v y → v (x + y) = max (v x) (v y)) := by
  exact fun x y a ↦ Valuation.map_add_of_distinct_val v a


-- There is a valuation v on ℝ such that v(1/2) > 1.
theorem valuation_on_reals : ∃(Γ₀ : Type) (_ : LinearOrderedCommGroupWithZero Γ₀)
  (v : Valuation ℝ Γ₀), (v (1/2)) > 1 := by
    have h := valuation_ring_no_half
    cases' h with B h
    use B.ValueGroup, inferInstance, B.valuation
    have g := valuation_le_one_iff B (1/2)
    rw[← not_iff_not] at g
    rwa[gt_iff_lt, ← not_le, g]
