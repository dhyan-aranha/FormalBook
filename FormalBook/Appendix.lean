import Mathlib.Tactic

noncomputable section

open ValuationSubring
open Algebra
open Polynomial

-- Any maximal subring of ℝ not containing 1/2 is a valuation ring.
lemma inclusion_maximal_valuation (B : Subring ℝ) (h1 : (1/2) ∉ B)
(h2 : ∀(C : Subring ℝ), (B ≤ C) ∧ (1/2) ∉ C → B = C) : ∃(D : ValuationSubring ℝ), D.toSubring = B := by
  -- We assume that B is not a valuationring
  by_contra no_vr
  have alpha_existence : ∃(α : ℝ), (α ∉ B ∧ α⁻¹ ∉ B) := by
  -- This is true, because B is not a valuationring
    by_contra H
    rw[← not_forall_not, not_not] at H
    simp_rw[← or_iff_not_and_not] at H
    let D : ValuationSubring ℝ :=
      { B with
        mem_or_inv_mem' := H}
    have for_contra : ∃ (D : ValuationSubring ℝ), D.toSubring = B := by
      use D
    tauto
  cases' alpha_existence with α H
  -- We consider B[α], B[α⁻¹] (as algebras over B)
  let Balpha := adjoin B {α}
  let Balpha' := adjoin B {α⁻¹}

  have alpha_in_Balpha : α ∈ Balpha := subset_adjoin rfl
  have alpha_in_Balpha' : α⁻¹ ∈ Balpha' := subset_adjoin rfl

  have algebramap : ∀x : B, (algebraMap ↥B ℝ) x = x := by
    intro x
    rfl
  -- -- We consider {2} as a subset of Balpha and {2} as a subset of Balpha'
  -- let (two : Set Balpha.toSubring) := {2}
  -- let (two' : Set Balpha'.toSubring) := {2}
  -- -- We view 2B[α], 2B[α⁻¹] as principle ideals,
  -- -- i.e. submodules generated by 1 element
  -- let twoBalpha := Submodule.span Balpha.toSubring two
  -- let twoBalpha' := Submodule.span Balpha'.toSubring two'


  have Balpha_contains_half : 1/2 ∈ Balpha := by
  -- otherwise there is a contradiction with maximality
    by_contra h
    have B_leq_Balpha : B ≤ Balpha.toSubring := by
      -- B is a subring of B[α]
      intro x h'
      lift x to B using h'
      apply Subalgebra.algebraMap_mem'
    have B_is_Balpha : B = Balpha.toSubring := by
      -- Here we use the maximality of B
      exact h2 Balpha.toSubring ⟨B_leq_Balpha, h⟩
    have Balpha_leq_B : Balpha.toSubring ≤ B := by
      exact le_of_eq_of_le (_root_.id (Eq.symm B_is_Balpha)) fun ⦃x⦄ a ↦ a
    have alpha_in_B : α ∈ B := Balpha_leq_B alpha_in_Balpha
    -- We have now shown that α ∈ B, but we also know that α ∉ B by assumption
    -- therefore we obtain a contradiction
    rw[← false_iff] at H
    rwa[H.1]


  have Balpha'_contains_half : 1/2 ∈ Balpha' := by
    -- This is essentially the same proof as above, only with primes
    by_contra h
    have B_leq_Balpha' : B ≤ Balpha'.toSubring := by
      -- B is a subring of B[α⁻¹]
      intro x h'
      lift x to B using h'
      apply Subalgebra.algebraMap_mem'
    have B_is_Balpha' : B = Balpha'.toSubring := by
      -- Here we use the maximality of B
      exact h2 Balpha'.toSubring ⟨B_leq_Balpha', h⟩
    have Balpha'_leq_B : Balpha'.toSubring ≤ B := by
      exact le_of_eq_of_le (_root_.id (Eq.symm B_is_Balpha')) fun ⦃x⦄ a ↦ a
    have alpha_in_B : α⁻¹ ∈ B := Balpha'_leq_B alpha_in_Balpha'
    -- We have now shown that α⁻¹ ∈ B, but we also know that α⁻¹ ∉ B by assumption
    -- therefore we obtain a contradiction
    have one_last : α⁻¹ ∉ B := H.2
    rw[← false_iff] at one_last
    rwa[one_last]

  let degree : Set ℕ := {n : ℕ | ∃(p : Polynomial B), p.natDegree = n ∧ (Polynomial.aeval α) p = 1/2}
  let degree' : Set ℕ := {n : ℕ | ∃(p : Polynomial B), p.natDegree = n ∧ (Polynomial.aeval α⁻¹) p = 1/2}

  -- any element of B[α] can be written as a polynomial in α with variables in B
  have contains_half : 1/2 ∈ ((Polynomial.aeval α).range : Subalgebra ↥B ℝ) := by
    rw[← adjoin_singleton_eq_range_aeval B α]
    exact Balpha_contains_half

  have is_nonempty : degree ≠ ∅ := by
    intro is_empty
    rcases contains_half with ⟨p, eval⟩
    have deg : p.natDegree ∈ degree := by
      exact ⟨p, by rfl, eval⟩
    rw[is_empty] at deg
    tauto

  have nonempty : degree.Nonempty := by
    exact Set.nonempty_iff_ne_empty.mpr is_nonempty

  -- any element of B[α⁻¹] can be written as a polynomial in α⁻¹ with variables in B
  have contains_half' : 1/2 ∈ ((Polynomial.aeval α⁻¹).range : Subalgebra ↥B ℝ) := by
    rw[← adjoin_singleton_eq_range_aeval B α⁻¹]
    exact Balpha'_contains_half

  have is_nonempty' : degree' ≠ ∅ := by
    intro is_empty
    rcases contains_half' with ⟨p, eval⟩
    have deg : p.natDegree ∈ degree' := by
      exact ⟨p, by rfl, eval⟩
    rw[is_empty] at deg
    tauto

  have nonempty' : degree'.Nonempty := by
    exact Set.nonempty_iff_ne_empty.mpr is_nonempty'

  -- Since the natural numbers are well-founded and degree and degree' are
  -- non-empty, we may conclude that degree and degree' have a minimal element
  let m := WellFounded.min wellFounded_lt degree nonempty
  let n := WellFounded.min wellFounded_lt degree' nonempty'

  have m_mem : m ∈ degree := WellFounded.min_mem wellFounded_lt degree nonempty
  have n_mem : n ∈ degree' := WellFounded.min_mem wellFounded_lt degree' nonempty'
  rcases m_mem with ⟨p, m_eq_degree_p, p_eval⟩
  rcases n_mem with ⟨q, n_eq_degree_q, q_eval⟩

  -- m and n are not equal to zero, because otherwise 1/2 would be in B
  -- We use that a polynomial of degree zero is constant and  that the
  -- evalauation of a contant polynomial lands in B (Polynomial.aeval_C)
  have zero_lt_m : m ≠ 0 := by
    intro m_eq_zero
    rw[← m_eq_degree_p, Polynomial.natDegree_eq_zero] at m_eq_zero
    rcases m_eq_zero with ⟨x, eq⟩
    rw[← eq, Polynomial.aeval_C, algebramap x] at p_eval
    rw[← p_eval] at h1
    apply h1
    exact SetLike.coe_mem x

  have zero_lt_n : n ≠ 0 := by
    intro n_eq_zero
    rw[← n_eq_degree_q, Polynomial.natDegree_eq_zero] at n_eq_zero
    rcases n_eq_zero with ⟨x, eq⟩
    rw[← eq, Polynomial.aeval_C, algebramap x] at q_eval
    rw[← q_eval] at h1
    apply h1
    exact SetLike.coe_mem x

  let v₀ := Polynomial.coeff q 0
  let two_v₀ := 2*v₀
  let one_minus_two_v₀ := 1-two_v₀

  by_cases leq : n ≤ m

  have lower_degree : (n-1) ∈ degree := by
    have two_eq_constant : Polynomial.C (2:B) = (2 : Polynomial ↥B) := by rfl
    have two_p_eval : (Polynomial.aeval α) (2 * p) = 1 := by
      rw[← two_eq_constant, map_mul, Polynomial.aeval_C, algebramap 2, p_eval]
      simp
      exact CommGroupWithZero.mul_inv_cancel 2 (Ne.symm (NeZero.ne' 2))
    have constant_in_poly :
      ∀(b : B), ∀(p : Polynomial B), (Polynomial.aeval α) ((Polynomial.C b) * p) = b * (Polynomial.aeval α) p := by
        intro b p
        rw[map_mul, Polynomial.aeval_C, algebramap b]
    have one_minus_two_v₀_eq : (aeval α) ((C one_minus_two_v₀) * (2*p)) = one_minus_two_v₀ := by
      rw[constant_in_poly one_minus_two_v₀ (2*p), two_p_eval]
      simp
    have one_eq : 1 = (aeval α) ((C one_minus_two_v₀) * (2*p) + (C two_v₀)) := by
      rw[← Eq.symm (aeval_add α), Polynomial.aeval_C, algebramap (two_v₀), one_minus_two_v₀_eq]
      exact sub_eq_iff_eq_add.mp rfl
    sorry
  sorry
  sorry



  -- let Balpha2 := Balpha.toSubring
  -- let Balpha'2 := Balpha'.toSubring
  -- have range : Set.range ↑(algebraMap B ℝ) = B := by
  --   ext x
  --   constructor
  --   . intro h

  --     sorry
  --   . intro h
  --     have x_is_y : ∃ y : B, y = x := CanLift.prf x h
  --     cases' x_is_y with y x_is_y'
  --     have H : (algebraMap B ℝ) y = x := x_is_y'
  --     rw[Set.mem_range]
  --     use y
  -- have closure : Balpha2 = Subring.closure (B ∪ {α}) := by
  --   rw[← range]
  --   exact adjoin_eq_ring_closure {α}



-- There exists a valuation subring of ℝ not containing 1/2.
lemma valuation_ring_no_half : ∃(B : ValuationSubring ℝ), (1/2) ∉ B := by
  let S := {A : Subring ℝ | (1/2) ∉ A}
  have sUnion_is_ub : ∀ c ⊆ S, IsChain (· ≤ ·) c → ∃ ub ∈ S, ∀ z ∈ c, z ≤ ub := by
    -- Idea: The upper bound is the union of the subrings.
    intro c subset chain
    -- def subring_to_set_of_sets : Set (Set ℝ) := {S.carrier | S ∈ c}
    let subring_to_set_of_sets : Set (Set ℝ) :=
      {Rset : Set ℝ | ∃R : Subring ℝ, R ∈ c ∧ Rset = R.carrier}
    let union_of_sets : Set ℝ := subring_to_set_of_sets.sUnion
    let ub : Subring ℝ :=                           -- We can also use subring.closure as that is the smallest subring containing all elements (in this case the thing itself) but then we need to show it is in S
    { carrier := union_of_sets,
      zero_mem' := by sorry,                        -- 0 is in the set
      one_mem' := by sorry,                         -- 1 is in the set
      add_mem' := by sorry,                         -- closure under addition
      mul_mem' := by sorry,                         -- closure under multiplication
      neg_mem' := by sorry }                        -- closure under negation
    have ub_mem_S : ub ∈ S:= by
      sorry
    sorry
  have h2 := zorn_le₀ S sUnion_is_ub
  rcases h2 with ⟨B, hl, hr⟩
  have h3 : ∀(C : Subring ℝ), (B ≤ C) ∧ (1/2) ∉ C → B = C := by
    -- Idea: This is exactly hr, so maybe change statement of
    -- inclusion_maximal_valuation to have hr as hypothesis.
    rintro y ⟨h6, h7⟩
    have h8 : y ∈ S := by
      exact h7
    have h5 : y ≤ B := hr h8 h6
    exact LE.le.antisymm h6 h5
  have h4 := inclusion_maximal_valuation B hl h3
  cases' h4 with D hd
  use D
  -- Idea: B ∈ S so (1/2) ∉ B. D=B implies (1/2) ∉ D.
  -- Maybe again try to change statement of inclusion_maximal_valuation to:
  -- B is a valuation ring.
  -- have B_no_half : 1/2 ∉ B := hl
  have D_no_half : 1/2 ∉ D.toSubring := by
    rwa[hd]
  exact D_no_half


lemma non_archimedean (Γ₀ : Type) [LinearOrderedCommGroupWithZero Γ₀] (K : Type) [Field K] (v : Valuation K Γ₀) :
  (∀(x y : K), v x ≠ v y → v (x + y) = max (v x) (v y)) := by
  exact fun x y a ↦ Valuation.map_add_of_distinct_val v a


-- There is a valuation v on ℝ such that v(1/2) > 1.
theorem valuation_on_reals : ∃(Γ₀ : Type) (_ : LinearOrderedCommGroupWithZero Γ₀)
  (v : Valuation ℝ Γ₀), (v (1/2)) > 1 := by
    have h := valuation_ring_no_half
    cases' h with B h
    use B.ValueGroup, inferInstance, B.valuation
    have g := valuation_le_one_iff B (1/2)
    rw[← not_iff_not] at g
    rwa[gt_iff_lt, ← not_le, g]
